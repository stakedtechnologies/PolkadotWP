# 6. プロトコルの詳細

本プロトコルは大きく３つのパートに分解することができる：コンセンサスメカニズム、パラチェーンインターフェイス、インターチェーン取引ルーティング。

## 6.1. リレーチェーンオペレーション

リレーチェーンはイーサリアムと似たように、ステイトがアドレスをアカウント情報（主に残高や取引回数）にマッピングしたステイトベースのチェーンになるだろう。アカウントをここに置くことには目的が一つある：システムで誰がどれだけのステイクを保持しているかを説明すること。そこには大きな違いはない、しかし：

- コントラクトはトランザクションによって配置することはできない。リレーチェーン上のアプリケーション機能を回避したいという欲求から、契約のパブリックデプロイのサポートをしない。
- 計算リソース（ガス）の使用量は計上されない；パブリック使用のための機能のみが直されるため、ガス計上はされなくなる。
- リストに挙げられたコントラクトが自動執行とネットワークメッセージアウトプットをすることを可能にする特殊な機能サポートされる。

リレーチェーンにVMがあり、それがEVMをベースにしている場合、単純さを最大化するためにいくつかの変更が必要である。
リレーチェーンにはコンセンサス、バリデーター、パラチェーンコントラクトを行うために、プラットフォーム専用のいくつかの組込みコントラクト（Ethereumの1-4アドレスのような）が存在している。

EVMではない場合、WebAssembly [2]（wasm）バックエンドが最も可能性の高い代替手段である。この場合、全体構造は似ているが、埋め込みコントラクトの必要はない。これがEVMのために作られた未熟な言語ではなく汎用言語用であるWasmを使う理由である。

現在のEthereumプロトコルからの全く異なる他のプロトコルの可能性は十分にある。
例えば、EthereumのSerenityのために提案されたように、同一ブロック内で競合しないトランザクションの並列実行を可能にする、簡易的なトランザクション受信フォーマットなど。

これは可能性は低いが、Serenityのような「純粋（Pure）」なチェーンがチェーンの基礎的なプロトコルとしてではなく、Relayチェーンとしてデプロイされるかもしれない。これにより、特定のコントラクトがステイキングトークン残高などを管理することができる。
現時点では、これは追加の複雑さと開発に不確実性を伴う価値がある程の十分なプロトコル簡素化を提供する可能性が低いと感じている。

コンセンサスメカニズム、バリデータセット、バリデーションメカニズムおよびパラチェインを管理するために必要な機能のピースがいくつもある。
これらはモノリシックプロトコルの下で一緒に実装することが可能である。ただし、モジュール性を高めるために、これらをリレーチェーンの「コントラクト」として説明する。

これは、それらが（オブジェクト指向言語のような）オブジェクトであることを意味すると解釈される。リレーチェーンのコンセンサスメカニズムによって管理されているが、必ずしもEVMのようなopcodesでプログラムとして定義されているわけでも、アカウントシステムを通じて個別にアドレス指定可能であるというわけでもない。

6.2. ステイキング コントラクト
このコントラクトは以下のようにバリデータセットを管理する。

- どのアカウントが現在バリデータであるか（Validators）；
- どのアカウントがすぐにバリデータになることができるか（Intentions）；
- どのアカウントがバリデータにノミネートするためにステイクしているか（Stashes）；
- ステイク量、許容ペイアウト率、アドレス、短期（セッション）アイデンティティを含むそれぞれの特性（Others）；

それは、アカウントが（その要件と共に）担保付き（bonded）のバリデータになる、ノミネートする、そして既存の担保付きの検証者がこのステータスからエグジットする意思を登録する。またバリデーションと正規化メカニズムのためのメカニズムも含みます。

6.2.1.ステークトークンの流動性
ネットワークセキュリティをステークトークンの全体的な「時価総額」に直結させるため、一般に、できるだけ多くのトータルステーキングトークンをネットワークメンテナンス操作内でステークすることが望ましい。これは、通貨のインフレを通し、収益をバリデータとして参加する人々に配ることによって、容易にインセンティブ設計することができる。しかし、そうすることは一つ問題を提起する：トークンがステークコントラクトでロックされるならば、価格向上を実現するためにどのように十分な流動性を維持できるのか？

これに対する1つの答えは、直接的なデリバティブコントラクトを許可し、ステイクされたトークン上で代替可能（Fungible)なトークンを保護することだ。これは信頼できる方法で手配するのが困難だ。さらに、これらのデリバティブトークンは、異なるユーロ圏の国債が代替可能ではないのと同じ理由で同等に扱うことはできない：原資産が破綻し、価値がなくなる可能性がある。ユーロ圏の政府では、これがデフォルトとなるかもしれない。しかしバリデータがステイクしたトークンの場合、バリデータの悪意を持った行動には処罰が伴う。

私たちは信条を守りながら、最も単純な解決策を選んだ：全てのトークンはステイクされない。つまりは、ある一定の割合（おそらく20％程度）のトークンが強制的に流動性を維持することを意味する。これはセキュリティの観点からは不完全だが、ネットワークのセキュリティに根本的な違いをもたらすことはまずありえない。ステイクの没収による賠償金の80％と、100％のステークの「完璧なケース」との大差はそれほどない。

ステイクされるトークンと流動的なトークンの比率はリバースオークションの仕組みによって案外簡単に決められる。基本的に、バリデーターになりたいトークン保有者はそれぞれ、参加するために必要となる最小支払い率を記載したオファーをステーキング契約に投稿します。各セッションの開始時に（セッションは定期的に、おそらく1時間に1回程度）、各バリデーターのステークとペイアウト率に従ってバリデータースロットが満たされる。これに対する１つの可能なアルゴリズムは、目標総賭け金をスロット数で割った数以下で、その額の半分の下限を下回らない賭け金を表す最低オファーを有するものを選ぶことであろう。スロットを埋めることができない場合は、満たすために下限が何らかの要因で繰り返し引き下げられる。

ステイクしているトークンをアクティブなバリデータにトラストレスにノミネートすることは可能だ。それはバリデータに責任を任せる事になる。ノミネーションは承認投票システムによって行われる。それぞれのノミネーター志望者は、自らの責任の下で彼らがステイクを賭けるのに十分な信頼を置く、一人以上のバリデータをステークコントラクト上に登録することができる。

各セッションで、ノミネーターの掛け金は1人、またはそれ以上のバリデーターに分散される。分散アルゴリズムは、総賭け金がバリデーターセットに最適化する。(The dispersal algorithm optimises for a set of validators of equivalent total bonds.) ノミネーターの賭け金は、バリデーターの責任の下に置かれ、バリデーターの行動応じて利益を得るか、または処罰として減額を受ける。

6.2.3. 債権の没収/バーン
特定のバリデーターの振る舞いは賭け金に懲罰的な減少をもたらす。賭け金が許容最小額を下回ると、セッションは途中で終了し、別のセッションが開始される。処罰対象のバリデーターの不正行為のリストには以下が含まれる：

- パラチェインブロックの有効性についてコンセンサスを提供できないパラチェイングループの一員である
- 無効なパラチェインブロックの有効性について積極的に署名する
- 利用可能として以前に投票されたアウトバウンドペイロードを供給することができない
- 合意プロセス中に非活動的である
- 競合するフォークのリレーチェーンブロックを検証する

不正な悪意のある行動のケースによっては、ネットワークの完全性が損なわれ（無効なパラチェインブロックに署名したり、フォークの複数の面を検証したりするなど）、その結果、債権の完全な没収により追い出されることがある。その他の、それほど深刻ではない不正行為（例えば、合意プロセスにおける非活動）または誰の責任か不明瞭である（無効なグループの一部であるなど）場合、代わりに、債権のごく一部の罰金を科されることがある。後者の場合、これはサブグループchurnによって、悪意のあるノードが健全なノードよりより大きな損失を被るようにする。

場合によっては（マルチフォーク検証や無効なサブブロック署名など）、各パラチェインブロックを常に検証するのは面倒な作業になるため、バリデーターがお互いの不正行為を検出することは困難である。ここでは、そのような不正行為を検証し報告するために、検証プロセス外部にある組織の支援を必要とする。その役割を担った存在はそのような活動を報告することで報酬を得る。彼らの「Fisherman（釣り人）」という名前は、そのような稀な報酬に由来している。

これらのケースは通常非常に深刻であるため、いかなる報酬も没収された債券から容易に支払うことができると我々は考えている。一般的に、大規模な再割り当てを試みるのではなく、バーン（つまり、何もしないこと）により再割り当てのバランスを取ることが好ましい。これはトークンの全体的な価値を増加させ、発見に関与する特定の関係者よりもむしろネットワークに対して補償する効果がある。これは主に安全メカニズムとしてのものである。それは大量の報酬を伴ってしまう場合、単一のターゲットに対して報告する極端なインセンティブを与えてしまう事になるかもしれないからだ。

一般的に、報酬はネットワークにとって検証を行うのに十分なほどの大きさである必要がある一方、特定のバリデータに不正行為を強制させるような、組織化されたハッキング攻撃のインセンティブになるほど大きくないことが重要である。

このようにして、報酬は不正行為を行ったバリデータの債権量を超えないようにする必要がある。これは、検証者が故意的に不正行為を行い、自分自身を通報する事で利益を得ないようにするためである。これへの対処法として、バリデータになるのに最低限の賭け金を必要とすることや、ノミネーターに賭け金が少ないバリデーターは不正行為を行うインセンティブが大きい事実を啓蒙するなどがある。

## 6.3. パラチェーンレジストリ

各パラチェインはこのレジストリで定義されている。それは比較的単純なデータベースのような構造であり、そして各チェーンに関する静的な情報と動的な情報の両方を保持する。

静的情報には、異なるクラスのパラチェインを区別する手段である検証プロトコルの識別情報とともに、チェーンインデックス（単純な整数）が含まれる。これによって有効な候補を提示するために委任されたバリデータによって正しい検証アルゴリズムが実行される。
最初のPOCでは、新しい検証アルゴリズムをクライアント自体に配置することに重点が置かれ、追加のクラスのチェーンが追加されるたびにプロトコルのハードフォークが事実上必要になる。しかし最終的には、クライアントがハードフォークなしで新しいパラチェインを効果的に処理できるように、厳密かつ効率的な方法で検証アルゴリズムを指定することが可能である。これに対する1つの可能な方法は、WebAssemblyのような確立された、ネイティブにコンパイルされた、プラットフォームに依存しない言語でパラチェイン検証アルゴリズムを指定することである。これが本当に実現可能であるかどうかを判断するには追加の研究が必要だが、もしそうであれば、ハードフォークをしないことにより大きな利点をもたらす可能性がある。

動的情報には、パラチェーンの入力キュー（6.6.で説明）など、グローバルな合意が必要なトランザクションルーティングシステムの側面が含まれている。

レジストリは、全国民投票(referendum)によってのみ追加されたパラチェインを持つことができる。これは内部で管理できるが、より一般的なガバナンス要素のもとでの再利用を促進するために、外部の国民投票コントラクトに入れられる可能性が高くなる。追加チェーンの登録およびその他のあまり正式でないシステムアップグレードのための投票要件（たとえば、必要なクォーラム、大多数の要件）に対するパラメータは、「マスター規約」に記載されるが、少なくとも最初はかなり慣習的な方法に従う。正確な定式化は本研究の範囲外であるが、例えば、システムのステイクの3分の1以上が積極的に投票するという、3分の2のスーパーマジョリティが賢明な出発点となるだろう。

追加の操作には、パラチェーンの一時停止と削除が含まれる。中断は決して起こらないであろうと願っているが、それはパラチェーンのバリデーションシステムに少なくともいくらかの扱いにくい問題があることを保護するセーフガードの役目を担っている。それが必要とされる可能性がある最も顕著な例は、妥当性またはブロックについて合意することができないようにバリデータを導く実装間の重大なコンセンサスの違いである。バリデータは、債権の没収前にそのような問題を発見できるようにするために、複数のクライアント実装を使用することをお勧める。

一時停止は緊急措置であるため、国民投票ではなく動的バリデータ投票によって実行されるだろう。再検証はバリデータからも国民投票からも可能である。

パラチェーンの削除は、国民投票の後に初めて行われ、スタンドアロンチェーンへの秩序ある移行を可能にするため、または他の何らかの合意システムの一部となるためには、かなりの猶予期間が必要である。猶予期間は数ヶ月程度である可能性があり、異なるパラチェーンがそれぞれの必要性に応じて異なる猶予期間を享受できるようにするために、パラチェインレジストリにチェーンごとで設定される可能性がある。

## 6.4. リレーブロックのシーリング

シーリングとは、本質的には正規化のプロセスを指す。つまり、オリジナルを意味のあるものにマッピングする基本的なデータ変換のことである。POWチェーンの下では、シーリングは事実上マイニングの同義語である。私たちの場合、それは特定のリレーチェーンブロックとそれが表すパラチェーンブロックの有効性、可用性、そして正規性に関するバリデータからの署名されたステートメントの収集を意味する。

基礎となるBFTコンセンサスアルゴリズムのメカニズムの説明は今回の範疇外となる。代わりに、合意形成ステートマシンを想定したプリミティブを使って説明する。最終的には、コアにあるいくつかの有望なBFT合意アルゴリズム（Tangaora [9]（Raft [16]のBFT版）、Tendermint [11]、HoneyBadgerBFT [14]）にインスパイアされることを期待している。 このアルゴリズムは、複数のパラチェーンに並行して合意に達する必要があるため、通常のブロックチェーン合意メカニズムとは異なる。一旦合意に達すると、私たちはその合意を反論できない証拠として記録することができ、それは参加者の誰もが提供することができる。我々はまた、処罰に対処する際、プロトコル内の不正行為は一般に不正行為をする参加者を含む小グループにする事により、付随的な被害を最小限に抑えることができると想定している。Tendermint BFTやオリジナルのSlasherなど、既存のPoSベースのBFTコンセンサススキームは、これらの主張を満たしている。

署名付きステートメントの形式をとる証明は、リレーチェーンブロックのヘッダー、およびその他の特定のフィールド（リレーチェーンのステイトツリーのルートおよびトランザクションツリーのルート）と共に配置される。

シーリングプロセスは、リレーチェーンのブロックと、リレーのコンテンツの一部を構成するパラチェーンのブロックの両方に対応する単一の合意生成メカニズムの下で行われる。パラチェーンは、サブグループによって別々に「コミット」された後に照合されるわけではない。これにより、リレーチェーンの処理がより複雑になるが、システム全体の合意を1段階で完了し、待ち時間を最小限に抑え、以下のルーティング処理に役立つ非常に複雑なデータ可用性の要件を満たすことができる。

各参加者のコンセンサスマシンの状態は、単純な（2次元の）表としてモデル化できる。各参加者（バリデータ）は、各パラチェインブロック候補ならびにリレーチェインブロック候補に関して、他の参加者からの署名付きステートメント（Vote）の形式で一組の情報を有する。情報セットは2つ：

- 利用可能性（Availability）：このバリデータはこのブロックからのトランザクションの一連の情報を出力していか；故に次のブロックのパラチェイン候補を適切に検証できる。バリデータは1（知られている）か0（まだ知られていない）のどちらかを投票することができる。1を投票した場合、このプロセスの残りの部分についても同様に投票することに一貫する。これに従わない後からの投票は罰の対象となる。

- 妥当性（Validity)：このパラチェインブロックは有効であり、全ての外部参照データ（例えばトランザクション）は利用可能か。これは、投票しているパラチェーンに割り当てられているバリデータにのみ関係する。彼らは1（有効）、-1（無効）または0（まだ知られていない）のどれかに投票することができる。彼らがゼロでない(non-zero)投票をしたら、このプロセスの残りの部分についても同様に投票することに一貫する。これに従わない後からの投票は罰の対象となる。

すべての検証者が投票を提出する必要がある。票は上記の規則によって修飾され、再提出されることがある。合意の進行は、並行して行われる各パラチェインに対する複数の標準的なBFT合意アルゴリズムとしてモデル化することができる。これらは少数の悪意のあるアクターが1つのパラチェイングループに集中することよって潜在的に妨害される。そのため、バックストップを確立するための全体的なコンセンサスが存在し、１つ以上の向こうパラチェインブロックにデッドロックされる最悪のシナリオを防ぐ。

個々のブロックの有効性のための基本的な規則（はバリデータ全体が、正規のリレーから参照されるユニークなパラチェイン候補になることについて合意に達することを可能にする）：

- 少なくとも3分の2のバリデータがポジティブに投票し、誰もネガティブに投票しないこと。
- 3分の1を超えるバリデータが、外に出て行く情報の可用性にポジティブに投票している。

正当性について少なくとも1つの正と負の投票がある場合、例外条件が作成され、悪意のある当事者がいるかどうか、または偶然の分岐があるかどうかを判断するためにバリデータのセット全体が投票する必要がある。有効と無効の他に、その両方に対する投票と同等である3番目の種類の投票が許可されている。つまり、ノードには意見の対立がある。これは、ノードの所有者が同意しない複数の実装を実行していることが原因である可能性があり、プロトコルにあいまいさがある可能性があることを示している。

すべての投票が完全なバリデータセットの確認を経た後、負けた側の意見が勝った側の意見の投票のある程度の割合（パラメータ化されるために；最大で半分、おそらくかなりより少ない）を占める場合、それは偶然起こったパラチェーンフォークと考えられ、そのパラチェーンは自動的にコンセンサスプロセスから中断される。さもなければ、それは悪意のある行為であると考えられ、反対意見に投票していた少数派を罰することになる。

結論は、正規性を示す一連の署名である。（The conclusion is a set of signatures demonstrating canonicality.）その後、リレーチェーンブロックはシーリングされ、次のブロックをシーリングするプロセスが開始される。

6.5.シーリングリレーブロックの改善
このシーリング方法はシステムの運用に強力な保証を提供するが、スケールに問題があると考えられている。なぜなら、パラチェインの重要な情報の可用性(Availability)は、バリデータ全体の3分の1以上によって保証されている必要があるためである。そしてこれは、チェーンが追加されるにつれて、すべてのバリデータの責任範囲が増大することを意味する。

オープンコンセンサスネットワーク内のデータの可用性は本質的に未解決の問題であるが、検証ノードにかかるオーバーヘッドを軽減する方法がある。 1つ目の解決策は、バリデータはデータの可用性に対する責任を負うが、実際にデータを保存・通信・複製する必要はないことである。このデータを編集している（あるいはまったく同じ）照合者に関連している可能性がある。
また、（このデータをコンパイルする照合者に関係、または同等であるかもしれない）2次データ格納庫(silos)が、支払いに対する利子/収入の一部を提供しているバリデータ、と可用性を保証するというタスクを管理できる。

しかしながら、これにより一時的なスケーラビリティを得られるが、根本的な問題を解決することにはならない。パラチェーンの追加は、さらなるバリデータを必要とするため、長期的なネットワークリソースの消費量（特に帯域幅の点で）はチェーンの二乗に比例して増加する。

最終的には、合計バリデータ×合計入力情報のバンド幅の基礎制限に手の打ち止めとなるだろう。これは、信頼されていないネットワークが、他の多くのノードにデータストレージのタスクを適切に分配することができないことに起因している。

6.5.1. 待ち時間の導入
この規則を緩和する1つの方法は、即時性の概念を緩和することだ。すぐにではなく、最終的にのみ可用性に投票する33％+ 1のバリデータを要求することで、指数関数的データ伝播をより有効に活用し、データ交換のピークを平準化することができる。 （証明されていないが）最も有り得そうな式は次のようになる。

（1）待ち時間=参加者×チェーン　（ latency = participants x chains ）

現在のモデルでは、システムのサイズはチェーンの数に比例してスケールし、それにより処理が確実に分散される。各チェーンは少なくとも1人のバリデータを必要とし、可用性検証を一定比率のバリデータに固定するため、参加者はチェーンの数が増えるにつれて同様に大きくなる。そしてこれに終始する：

（2）待ち時間= size2　( latency = size2 )

つまり、必要な帯域幅と可用性がネットワーク全体で認識されるまでの待ち時間（ファイナライズ前のブロック数とも呼ばれる）は、システムのスケールの2乗に比例して増加する。これは大きな成長要因であり、注目に値するロードブロッカーになる可能性があり、「平坦ではない（non-flat）」パラダイム（リレーチェーンのツリーを介したマルチレベルルーティングを行うため、複数の「Polkadots」を階層的に構成するなど）を実現する。

6.5.2.パブリック参加
もう1つの可能性のある方向性は、マイクロクレームシステムを通じたプロセスへの一般参加を許可することである。Fishermanと同様に、入手可能性を主張する検証者を監視する外部の存在がありえる。彼らの仕事は、そのような可用性を示すことができないように見える人を見つけることで、他のバリデータにミクロの苦情を申し立てることができる。システムをほとんど役に立たなくするようなシビル(sybil)攻撃を軽減するために、電力またはステークボンドを使用することができる。

6.5.3. 可用性の保証人
最終的な方法は、「可用性保証者」として2組目のステイク済みバリデータをノミネートすることである。これらは通常のバリデータと同じように結合され、同じセットから取られることさえ可能だ（少なくともセッションごとに、長期間にわたって選択される）。通常のバリデータとは異なり、パラチェインを切り替えるのではなく、重要なインターチェーンデータの可用性を証明するために単一のグループを形成する。

これには、参加者とチェーン間の同等性が緩和されるという利点がある。本質的に、チェーンは（元のチェーンバリデータセットと一緒に）成長することができるが、参加者、特にデータ可用性テストに参加している参加者は、最低限の準線形(sub-linear)に留まる可能性がある。

6.5.4. 照合者（Collat​​or）の設定
このシステムの重要な側面の1つは、どのパラチェイン内にもブロックを作成するための健全なコレクターの選択が行われていることを確認することである。単一の照合者がパラチェインを支配していた場合、外部データの可用性が不足する可能性はそれほど明白ではないため、いくつかの攻撃がより実行可能となる。

1つの選択肢は、擬似ランダムメカニズムでパラチェインブロックを人為的に重み付けすることにより、照合者の多様化を行うことだ。第一に、合意メカニズムの一部として、バリデーターが「より重い」と判断したパラチェインブロック候補を支持することを要求する。同様に、バリデータが最も重いブロックを提案することを動機付ける必要がある - これは彼らの報酬の一部を候補の重さに比例させることを通してなされるかもしれない。

照合者が彼らの候補が勝利候補として選択される合理的公平な機会が与えられることを確実にするために、パラチェインブロック候補の具体的な重みを各照合者のランダム関数で決定する。たとえば、照合者のアドレスと、作成されているブロックのポイントの近くで決定される暗号的に安全な疑似乱数の間のXOR距離の測定（概念的な「勝利チケット」）。これにより、各照合者（より具体的には各照合者のアドレス）に、候補者ブロックが他のすべての候補者よりも「勝つ」というランダムなチャンスが与えられる。

1人の照合者が勝利チケットに近いアドレスを「マイニング」してそのブロックをお気に入りにするというシビル攻撃を防ぐために、照合者のアドレスに慣性（inertia）を導入する。これは、アドレスに基準金額の資金があることを要求するのと同じくらい簡単かもしれない。よりエレガントなアプローチは、問題のアドレスに溜まっている資金の量で、勝利チケットの近くに重みを付けることだ。モデリングはまだ行われていないが、このメカニズムによって、ごくわずかなステイク者でも照合者として貢献できる可能性がある。



6.5.5. 太りすぎた（Overweight）ブロック
バリデータセットが危険に晒されている場合、有効ではあるが実行と検証に時間がかかるブロックを作成して提案する可能性がある。バリデータグループは、ショートカットを可能にする特定の情報が既に知られていない限り、実行するのに非常に長い時間がかかるブロックを合理的に形成できるので問題となる。 1人の照合者がその情報を知っていれば、他の古いブロック処理をしている人に対し、自分の候補者を受け入れさせることに明らかなアドバンテージとなる。これらのブロックを太りすぎ(Overweight)と呼ぶ。

追加の注意点はあるが、これらのブロックを送信して検証するバリデータに対する保護は、無効なブロックとほぼ同じように考えられる。ブロックを実行するのにかかる時間は主観的であり、投票の最終結果は不正行為については、基本的に3つに分類される。 1つの可能性は、ブロックが明らかに太りすぎではないということだ - この場合、3分の2以上がブロックをある限度内で実行できると宣言している（例えば、ブロック間の合計許容時間の50％）。２つ目は、ブロックが確実に太り過ぎであるということだ。これは、3分の2以上が、制限内でブロックを実行できないと宣言した場合。 最後の可能性はバリデータ間の意見が半分に割れることだ。この場合、我々は何らかに比例した罰をすることを選ぶかもしれない。

バリデータがいつ太りすぎのブロックを提案している可能性があるかをバリデータが確実に予測できるようにするには、ブロックごとに自分のパフォーマンスに関する情報を公開するように要求することを勧める。十分な期間にわたって、彼らが判断しようとしている仲間と比較して彼らの処理速度をプロファイルすることを可能にするはずだ。

6.5.6. コレーター保険
バリデータに関して１つの問題が残っている：ＰｏＷネットワークとは異なり、有効性について照合者のブロックをチェックするために、彼らは実際にその中のトランザクションを実行しなければならない。悪意のある照合者は、無効な、または太りすぎのブロックをバリデータに供給することができ、グリーフ（リソースの無駄遣い）を引き起こし、潜在的にかなりの機会損失を強制する。

これを軽減するために、バリデータ側で単純な戦略を提案する。第一に、バリデータに送られるパラチェインブロック候補は資金があるリレーチェーン口座から署名されなければならない。そうでない場合、バリデータはすぐにそれを削除する必要がある。第二に、そのような候補者は、ある上限までの口座内の資金の額、過去に丁寧に提案した過去のブロック数までの組み合わせ（例えば、乗算）によって優先的に順序付けされるべきである。 ）、および前述のように当選チケットへの近接係数。上限は、無効なブロックを送信した場合にバリデータに支払われる懲罰的損害賠償と同じでなければならない。

無効または過重のブロック候補を検証者に送信することを照合者にさせないために、検証者は不正な照合者の口座にある資金の一部または全部を不正な検証者に移すという影響で、不正行為を主張する違反ブロックを含むトランザクションを次のブロックに入れることができる。このタイプの取引は、罰金の前に照合者が資金を取り出すことをできないようにするために、他の取引を前倒しで実行する。損害賠償として譲渡される資金の額は、まだモデル化されていない動的パラメータだが、生じたグリーフのレベルを反映するためのバリデータブロック報酬の割合となる可能性がある。悪意のある検証者が照合者の資金を勝手に没収するのを防ぐために、照合者は小額の入金の見返りにランダムに選択された検証者の陪審員による検証者の決定に上訴することができる。彼らがバリデータの支持を得た場合、デポジットは彼らによって消費される。そうでなければ、保証金は返却され、バリデーターは罰金を科される（バリデーターははるかにアーチ型の位置にあるので、罰金はかなり多額になるだろう）。

6.6. チェーン間トランザクションルーティング
チェーン間トランザクションルーティングは、リレーチェーンとそのバリデータの重要なメンテナンスタスクの1つである。これは、転記されたトランザクションが、ある信頼要件を必要とせずに、ソースパラチェーンからの希望する出力から他のデスティネーションパラチェーンの非交渉入力になる方法を決定するロジックである。

私たちは上の言葉を慎重に選ぶ。特に、この投稿を明示的に承認したために、ソースパラチェイン内にトランザクションがあったことを要求しない。私たちのモデルに課せられる唯一の制約は、パラチェインが全体のブロック処理出力の一部としてパッケージされ、ブロックの実行の結果であるポストを提供しなければならないということだ。

これらのポストは複数のFIFOキューとして構成されている。リストの数はルーティングベースと呼ばれ、16前後になる場合がある。特に、この数は、マルチフェーズルーティングに頼らなくてもサポートできるパラチェインの数を表す。当初、Polkadotはこの種の直接ルーティングをサポートするが、最初の一連のパラチェーンをはるかに超えてスケ​​ールアウトする手段として、1つの可能な多相ルーティングプロセス（「ハイパールーティング」）の概要を説明する。

すべての参加者が次の2つのブロックn、n + 1のサブグループを知っていると仮定する。要約すると、ルーティングシステムは次の段階に従う。

- CollatorS : Contact members of V alidators[n][S]
- CollatorS: FOR EACH subgroup s: ensure at
least 1 member of V alidators[n][s] in contact
- CollatorS : FOR EACH subgroup s: assume egress[n − 1][s][S] is available (all incoming post
data to ‘S‘ from last block)
- CollatorS: Compose block candidate b for S:
(b.header, b.ext, b.proof, b.receipt, b.egress)
- CollatorS : Send proof information proof[S] = (b.header, b.ext, b.proof, b.receipt) to
V alidators[n][S]
- CollatorS : Ensure external transaction data b.ext
is made available to other collators and validators
- CollatorS : FOR EACH subgroup s: Send egress information egress[n][S][s] = (b.header, b.receipt, b.egress[s]) to the re- ceiving sub-group’s members of next block
V alidators[n + 1][s]
- V alidatorV : Pre-connect all same-set members
for next block: let N = Chain[n + 1][V ]; connect
all validators v such that Chain[n + 1][v] = N
- V alidatorV : Collate all data ingress for this block: FOR EACH subgroup s: Retrieve egress[n − 1][s][Chain[n][V ]], get from other val- idators v such that Chain[n][v] = Chain[n][V].Possibly going via randomly selected other val-
idators for proof of attempt.
- V alidatorV : Accept candidate proofs for this
block proof[Chain[n][V ]]. Vote block validity
- V alidatorV : Accept candidate egress data for next block: FOR EACH subgroup s, accept egress[n][s][N ]. Vote block egress availability; re- publish among interested validators v such that
Chain[n + 1][v] = Chain[n + 1][V ]. • V alidatorV : UNTIL CONSENSUS

ここで、egress [n] [from] [to]は、ブロック番号 'n'のparachain 'from'からparachain 'to'への投稿に対する現在の出力キュー情報である。 Collat​​orSは、パラチェインSのCollator。Validators [n] [s]は、ブロック番号nのパラチェインsのバリデータのセット。逆に、Chain [n] [v]はバリデータvがブロック番号nに割り当てられているパラチェイン。 block.egress [to]は、宛先parachainがtoである、あるparachainブロックブロックからの投稿の出力キュー。

照合者は、自分のブロックが正規になったことに基づいて料金を徴収するため、次のブロックの送信先ごとに、サブグループのメンバーに現在のブロックからの出力キューが通知される。バリデータは（パラチェイン）ブロックについてコンセンサスを形成することのみを奨励されている。原則として、バリデータは照合者と忠誠を尽くし、他の照合者のブロックが標準的になる可能性を減らすために共謀することができるが、これはパラチェインのバリデータをランダムに選択するため整理するのが困難であり、合意プロセスを妨げるパラチェインブロックに対して支払うべき料金の減少で擁護される可能性がある。

6.6.1.外部データの可用性：Parachainの外部データが実際に利用可能であることを保証することは、ネットワーク全体に作業負荷を分散することを目的とした分散型システムにおける永続的な問題である。この問題の核心は可用性の非対話的な証明も非可用性のいかなる種類の証明も行うことが出来ないので、BFTシステムが正確に何らかの外部のデータの可用性に依存する遷移を適切に検証するためにシステムの許容可能なビサンチンノードの最大数＋１がデータが利用可能であることを述べる可用性の問題である。

Polkadotのようにシステムを適切にスケールアウトするには次のような問題が生じる。一定割合のバリデータがデータの可用性を証明しなければならず、バリデータが利用可能であると表明する前に実際にデータを保管したいと考えている場合、システムのサイズ（バリデータの数）に伴って帯域幅・ストレージ要件が増大するという問題をどのように回避すれば良いのか。その答えとして考えられるのは、別のバリデータのセット（可用性保証人）を用意することである。これについては6.5.3で説明する。

二次的なトリックもある。グループとして、collators(照合者）は選択したパラチェイン全てのデータが利用可能であることを保証する特有のインセンティブを持っている。なぜならデータがなければ取引手数料を収集するためのブロックを作成することが出来ないからである。collatorsもグループを形成するが、そのメンバーは様々で（Parachain バリデータグループのランダムな性質による）、簡単に入ることはできず、簡単に証明できる。したがって最近のcollators（おそらく最後の数千ブロック）は特定のParachainブロックの外部データの可用性に対するchallengesを、少ないbondでバリデータに発行することができる。

バリデータは明らかに違反しているバリデータのサブグループのメンバと連絡をとり、データを取得してcollatorに返すか、escalate the matter by testifying to the lack of availability（データを提供することを直接拒否することは、bondを没収する犯罪であり、よって不正行為を行ったバリデータは単に接続を切断する可能性が高い）、同じテストを実行するために別のバリデータに連絡する必要がある。後者の場合はcollatorのbondは返される。

このような可用性のない証言を作ることができるバリデータのquorum(分散システムにおいて、分散トランザクションが処理を実行するために必要な最低限の票の数）が限界に達すると、それらは解放され、不正なサブグループは罰せられ、ブロックは元に戻される。

6.6.2ポストルーティング。各parachainヘッダには”egress-trie-root”が含まれている。これは”routing-base-bins”を含む、トライのルートであり、各binは出力ポストの連結されたリストである。特定のパラチェーンのブロックが特定の宛先のパラチェーンの特定の出力キューを有していたことを証明するために、マークル証明をパラチェーンバリデータ全体に提供することができる。

パラチェーンブロックの処理の開始時にそのブロックにバインドされている他のパラチェーンの出力キューはブロックの入力キューにマージされる。どのパラチェーンブロックペア間にも有利性を提供しない決定論的演算を達成するために、CSPR9サブブロック順序付けを強く仮定した。Collatorは新しいキューを計算し、parachainのロジックに出力キューを排出する。

入力キューの内容は、parachainブロックに明示的に書き込まれる。これには主に２つの目的がある。第一にparachainは他のparachainから分離して信頼できるように同期化できることを意味する。第二にもし入り口キュー全体が単一ブロックで処理できないなら、データロジスティックを単純化する。バリデータとcollatorsは特にキューのデータソースを保持することなくブロックを処理することができる。

もしparachainの入力キューがブロック処理の終了時に閾値を超えている場合、リレーチェーンで飽和とマークされ、クリアされるまでそれ以上のメッセージはこない。マークル証明はparachainブロック証明におけるcollatorの動作の忠実性を実証するために使用される。

6.6.3 批評この基本的なメカニズムに関連する小さな欠陥の一つはpost-bomb attackである。これは全てのパラチェーンが特定のパラチェーンに可能な最大量のpostを送ることである。これによりターゲットの入力キューが一度に結び付けられるが、標準的なDosアタック以上の被害は発生しない。

N個のparachain、N✖️M個の合計バリデータ、およびparachainごとのL個のcollatorsについて、よく同期された悪意のない一連のcollatorsおよびバリデータを用いて正常に動作することにより、ブロックごとの合計データ経路を以下のように分類することができる。

バリデータ：M-1+L+L: M-1はParachainセット内の他のバリデータ用であり、候補parachainブロックを提供する各collator用のLと、前のブロックの出力ペイロードを必要とする次のブロックの各collator用の第２のLである。後者は、実際には最悪の場合の操作に似ている。これはCollatorがそのようなデータを共有する可能性が高いからである。

Collator:M+kN:Mは関連する各Parachainブロックバリデータへの接続用、kNは次のブロックの各parachainバリデータの一部のサブセットへの出力ペイロードのシード用である。（といくつかの好ましいcollators)

よってノードごとのデータ：パスの方法はシステム全体の複雑さに比例して増加する。これは理に通ってるがシステムが数百、数千のParachainにスケールすると複雑性の増加率を低くする代わりに、ある程度の通信遅延が吸収される可能性がある。この場合、記憶バッファ及び待ち時間を導入するコストで瞬時経路の数を減少させるために、”multi-phase roouting algorithm”を使用される。

6.6.4 "Hyper-cube Routing" 
“Hyper-cube Routing”は、上記の基本的なルーティングメカニズムの拡張として構築できるメカニズムである。本質的にparachainとサブグループの数でノードのコネクティビティを成長させるのではなく、parachainの対数でのみ成長させる。postsは最後のデリバリの途中でいくつかのparachainのキューの間を移動することができる。

ルーティング自体は決定論的で単純である。まず入力/出力のbinsの数を制限するところから始める。parachainの総数ではなくルーティングベース(b)である。これはparachainの数が変化すると固定され、代わりに経路指数(e)が上昇する。このモデルの下で、メッセージボリュームはOと共に成長し、経路は一定のままであり、O（e)と共に待ち時間（またはデリバリに必要なブロック数）がある。

このルーティングモデルはe次元の超立方体であり、立方体の各辺はb個の可能な位置を持つ。ブロックごとに一つの軸に従ってルーティングする。軸をラウンドロビン方式で交代させることで、eブロックの最悪の場合のデリバリ時間を保証する。

parachain処理の一部として、current block number（and thus routing dimension）を指定すると、入力キューで見つかった外部バウンドメッセージは適切な出力キューのbinに即座にルーティングされる。このプロセスはデリバリルート上の各ホップに対して追加のデータ転送を必要とするが、これはデータペイロードデリバリを必要とするが、データペイロードデリバリのいくつかの代替手段を使用し、post-trie内のポストの全ペイロードではなく、参照のみを含むことによって緩和されえる問題である。

4 parachains、b=2 、e=2、を使用するシステムでこのようなハイパーキューブルーティングの例を示す。

Phase 0, on each message M:
• sub0: if Mdest ∈ {2,3} then sendTo(2) else keep • sub1: if Mdest ∈ {2,3} then sendTo(3) else keep • sub2: if Mdest ∈ {0,1} then sendTo(0) else keep • sub3: if Mdest ∈ {0,1} then sendTo(1) else keep

Phase 1, on each message M:
• sub0: if Mdest ∈ {1,3} then sendTo(1) else keep • sub1: if Mdest ∈ {0,2} then sendTo(0) else keep • sub2: if Mdest ∈ {1,3} then sendTo(3) else keep • sub3: if Mdest ∈ {0,2} then sendTo(2) else keep

ここの二つの次元は宛先インデックスの最初の２ビットであることがわかる、最初のブロックでは上位ビットのみが使用される。２番目のブロックは下位ビットを扱う。両方が発生するとポストがルーティングされる。

6.6.5 セレンディピティの最大化。
基本提案の一の変更は各サブグループにcー１バリデータを有するc２ーcバリデータの固定合計をみることになる。各ブロックはparachain間でバリデータ構造の構造化されていない再分割化があるのではなく、各parachainのサブグループの代わりに、各バリデータは次のブロックの固有の異なるparachainのサブグループに割り当てられる。これは任意の二つのブロックの間に任意の二つのparachainのペアに対して、parachainの責任を交換した２つのバリデータが存在するという不変性に繋がる。これを使用して可用性を絶対的に保証することはできないが（１つのバリデータではたとえ善意であっても時折オフラインになってしまう。）それでも一般的なケースを最適化できる。

このアプローチには合併症がないわけではない。parachainを追加するとバリデータセットの再編成も必要になる。さらにバリデータの数はparachainの数の２乗に結び付けられているため、最初は非常に小さく始まり、最終的には非常に早く成長し、約５０parachainの後には支持できなくなる。いずれも主要な問題ではない。最初のケースではバリデータセットの再構成はいずれにしても定期的に行う必要がある。バリデータセットのサイズに関してはあまりにも小さい場合、integer factor(整数係数）をバリデータの全体の合計に適用して、複数のバリデータを同じparacahinに割り当てることができる。6.6.4で議論されたハイパーキューブルーティングのような”multi-phase routing mechanism”は多数のチェインがあるとき、多数のバリデータの必要性を軽減するだろう。

6.7 Parachain検証：
バリデータの主な目的はよく結合されたアクターとしてパラチェーンのブロックが有効であることを証明することである。これには状態遷移、含まれる外部トランザクション、入力キュー内の待機ポストの実行、及び出力キュー内の最終状態が含まれる。プロセス自体はかなり単純である。バリデータが前のブロックをシール（封印）すると次のコンセンサスのための候補parachainブロック候補を提供する作業を自由に開始できる。
最初にバリデータはparachain collatorまたはco-validatersのいずれかを使用して、parachainのブロックの候補を見つける。parachainブロックの候補データはブロックのヘッダ、前のブロックのヘッダ、含まれる外部入力データ(EthereumやBitcoinではこのようなデータはトランザクションと呼ばれるが、原則として任意の目的のために任意のデータ構造を含むことができる。）出力キューデータ、状態遷移有効性を証明する内部データ(Ethereumの場合は、各トランザクションの実行に必要な様々な状態/ストレージ/トライ/ノード）を含む。実証的実験では最近のEthereumブロックに対するこの完全なデータセットが数百KiBであることを示している。

同時にまだ実行されていない場合、バリデータは前のブロックの遷移に関する情報を取得使用とする。最初は前のブロックのバリデータから取得し、後でデータの可用性について署名する全てのバリデータから取得する。
バリデータがそのような候補ブロックを受け取ると、バリデータはそれをローカルで検証する。検証プロセスはparachainクラスのバリデータモジュールに含まれる。このモジュールは合意に依存するソフトウェアモジュールであり、Polkadot（しかし原理的にはC ABIライブラリは、単一の「参照」の実装のみ持つことから適切な安全性の低下を伴って、単一のライブラリを実装間で共有することを可能にすることができる）の実装のために作成する必要がある。
このプロセスでは。前のブロックのヘッダが使用され、ハッシュを記録するために最近合意されたリレーチェーンブロックを介してその識別情報が検証される。親のヘッダの正規
性が確認されると、特定のparacahinクラスの検証関数が呼び出される。これは複数のデータフィールド（以前のものとほぼ同じ）を受け入れ、ブロックの有効性を宣言する単純なブール値を返す単一の関数である。

このような検証関数のほとんどは、まず親ブロックから直接派生可能なヘッダフィールドをチェックする。（例 親ハッシュ、number)その後、トランザクションやポストを処理するために必要に応じて内部データ構造を設定する。Ethereumのようなチェーンでは、トランザクションの完全な実行に必要なノードをトライ・データベースに格納する。他のタイプには予備メカニズムがあるかもしれない。

完了すると、入力ポストと外部トランザクション（外部データが表すものであれば）が制定され、チェーンの仕様に従ってバランスが取られる。（合理的なデフォルトは外部トランザクションが処理される前に、全ての入力ポストが処理されることを要求するかもしれないがparachainのロジックが決定することである。）この制定により、一連の出力ポストが作成され、これらがcollatorの候補と一致することが検証される。最後に適切に設定されたヘッダが候補のヘッダと照合される。

完全に検証された候補ブロックを利用して、バリデータはそのヘッダのハッシュに投票し、必要な全ての検証情報をそのサブグループ内のco-validatorsに送信することができる。

6.7.1 Parachain
paracahainのcollatorは現在のブロックチェーンネットワーク上のマイナーの仕事の大半をこなす”unbonded operators”である。これらは特定のparacahainに特異的である。オペレートするためにはリレーチェーンと完全に同期してあるパラチェーンの両方を維持しなければならない。

”完全同期”の正確な意味はparacahinのクラスに依存するがparacahin入力キューの現在の状態は常に含まれる。Ethereumの場合、少なくとも最後の数ブロックのMerkleツリーデータベースを維持する必要があるが、アカウントの存在を示すBloomフィルタ、familial 情報、ログ出力、block numberの逆検索テーブルなど、その他様々な可能性がある。
二つのチェーンの同期を保つことに加えて、それはまた、トランザクションキューを維持し、パブリックネットワークから適切に検証されたトランザクションを受け入れることにによってトランザクションを”fish"しなければならない。キューとチェーンを使用して各ブロックで選択されたバリデータの新しい候補ブロックを作成し（リレーチェーンが同期化されているので、アイデンティティが分かっている）proof-of-validityなどの様々な補助的情報と共にピアネットワーク経由で送信できる。
トラブルのために含まれている取引に関する全ての手数料を徴収する。この仕組みには様々な経済学が導入されている。過度に競争の激しい市場では、collatorsの余剰性がある場合、特定のcollatorsのブロックを含めるインセンティブを与えるために、取引手数料をparachainバリデータと共有することができる。同様にcollatorsの中にはブロック検証者にとって魅力的なもにするために支払う必要のある料金を引き上げる場合もある。この場合自然市場が形成され、より高い手数料が列に並ばず、より早くチェーンに含まれるべきである。

6.8 Networking
 EthereumやBitcoinのような伝統的なブロックチェーン上のネットワークはかなり単純な要件を持っている。全てのトランザクションとブロックは、undirected gossipでブロードキャストされる。同期化は特にEthereumとの同期化より複雑であるが、実際にはこのロジックにはいくつかの要求及び応答メッセージタイプを解決するプロトコル自体ではなく、ピア戦略に含まれていた。

Ethereumは単一のピア接続上で多数のサブプロトコルが多重化することを可能にし、同じピアオーバーレイが多数のp2pプロトコルを同時にサポートするdevp2pプロトコルを使用して、現在のプロトコルオファリングに進化したが、プロトコルのEthereum部分は比較的単純なままであり、p2pプロトコルはQoSサポートなどの重要な機能が欠落したままの未完成のものである。残念なことにもっとユビキタスな”web3”プロトコルを作ろうという試みは大失敗に終わり、それを使っている唯一のプロジェクトはEthereumのクラウドセールから明示的に資金提供されたものだった。
Polkadotの必要条件はもっと重要だ。完全に統一されたネットワークではなく、Polkadotにはピア構成に対して異なる要件を持つ複数のタイプの参加者と、特定のデータについてconversing(会話する）傾向のある複数のネットワーク”avenues”(大通り）がある。これは実質的により構造化されたネットワークオーバーレイ（及びそれをサポートするプロトコル）が必要になる可能性が高いことを意味する。さらに新しい種類の”chain”のような将来の追加を用意にする拡張性は、それ自体新しいオーバーレイ構造を必要とする可能性がある。
ネットワークプロトコルがどのようになるかの詳細な議論はこのホワイトペーパーの範囲外であるが、いくつかの必要条件の分析は合理的である。ネットワーク参加者を大まかに３つの部分集合のそれぞれ二つの集合（リーレーチェーン、パラチェーン）に分けることができる。parachainの参加者は他のparachainの参加者とは対照的に、自分自身の間のconversing(会話）にのみ関心があると述べることもできる。

- Relay-chain participants:
- Validators: P, split into subsets P[s] for each parachain	
- Availability Guarantors: A (this may be represented by Validators in the basic form of the protocol)
- Relay-chain clients: M (note members of each parachain set will also tend to be members of M)
- Parachain participants:
- Parachain Collators: C[0], C[1], . . .
- Parachain Fishermen: F[0], F[1], . . .
- Parachain clients: S[0], S[1], . . .
- Parachain light-clients: L[0], L[1], . . .

一般にこれらのセットのメンバー間で発生する傾向のある特定のクラスの通信には次のようなものがある。

- P|A <-> P|A: The full set of validators/guarantors must be well-connected to achieve consensus.
- P[s] <-> C[s] | P[s]: Each validator as a member of a given parachain group will tend to gossip with other such members as well as the collators of that parachain to discover and share block candidates.
- A <-> P[s] | C | A: Each availability guarantor will need to collect consensus-sensitive cross-chain data from the validators assigned to it; collators may also optimise the chance of consensus on their block by advertising it to availability guarantors. Once they have it, the data will be disbursed to other such guarantor to facilitate consensus.
- P[s] <-> A | P[s']: Parachain validators will need to collect additional input data from the previous set of validators or the availability guarantors.
- F[s]<->P:When reporting, fishermen may place a claim with any participant.
- M <-> M | P | A: General relay-chain clients disburse data from validators and guarantors.
- S[s] <-> S[s] | P[s] | A: Parachain clients disburse data from the validator/guarantors.
- L[s] <-> L[s] | S[s]: Parachain light clients disburse data from the full clients.

効率的な転送メカニズムを保証するには、Ethereumのdevp2pのように、各ノードがピアのfitnessを区別しないフラットなオーバーレイネットワークが適しているとは考えられない。適切なピアが適切なタイミングで”serendipitiously(偶然に)"接続されることを保証するために、積極的に先読み計画するだけでなく、適度に拡張可能なピア選択及び検出メカニズムをプロトコル内に含める必要がある。

適切にスケールアウトされたマルチチェーンの場合、collatorsはそれに応じて選択されたバリデータに継続的に再接続する必要があるか、バリデータのサブセットと継続的な合意を必要とし、バリデータが自分自身にとって役に立たない大部分の時間の間、それらが切断されないことを保証する必要がある。またcollatorsは可用性保証セットへの一つ以上の安定した接続を維持し、consensus-sensitiveデータの迅速な伝播を保証しようとする。

可用性保証の主な目的は、相互の安定した接続、バリデータ（彼らが証明する合意と合意に不可欠なparachainデータのために）collators(parachain データ用）、fisherman,full client(情報拡散のために）を維持することである。バリデータは他のバリデータ、特に同じサブグループにあるバリデータや、parachainブロック候補を提供できる任意のcollatorsを探す必要がある。

fishermanは一般的なリレーチェーンやparachain clientと同様に一般的にバリデータや保証人に接続を開いたままにしておくことを目的とするが、それ以外の点では自分と似た多くのノードある。parachain light clirent は他のparachain light clientだけでなく、parachain full clientに接続されることを同様に目的とする。


6.8.1 Peer Churnの問題　＊churn<-搔きまわす
基本プロトコル提案では、これらのサブセットの各々は、parachain遷移を検証するために割り当てられたバリデータがランダムに選択されるので、各ブロックで絶えずランダムに変化する。これは異なる（ピアでない）ノード間でデータを渡す必要がある場合に問題になる必要がある。hop-distance(したがって最悪の場合の待ち時間）がネットワークサイズ（ここではKademia-like プロトコルが役に立つかもしれない。）の対数でのみ増加することを保証するために、公平に分散されwell-connectedピアネットワークに頼るか、ノードの現在の通信ニーズを反映するピアセットを維持するために必要な接続ネゴシエーションを行うためにより長いblock timesを導入しなければならない。

いずれも優れた解決策ではない。ネットワークに長時間のblock timeがかかると特定のアプリケーションやチェーンでは使用できなくなる可能性がある。完全に公平で接続されたネットワークであっても、関心のないノードが不要なデータを転送しなければならないような拡張が進むと、帯域幅はかなり無駄になる。

両方向が解決の一部を形成する可能性があるが、待ち時間を最小にするのに役立つ合理的な最適化は、一連のブロックの間だけメンバーシップを再割り当てする（例えば、15のグループでは４秒のblock timeでは、接続の変更は毎分一回のみであることを意味する。）かメンバーシップを増分的に回転させる（例えば、各parachainに15のバリデータが割り当てられているとすると、平均して完全にユニークなセットの間は１分になる）ことによって、これらのparachainバリデータセットのボラティリティを制限することである。”peer churn”の量を制限しparachainセットの部分的な予測可能性を通して有利なピア接続が十分に確立されていることを保証することによって各々ノードが永続的に予期せぬピア選択を維持するのを助けることができる。

6.8.2 有効なネットワークプロトコルへのパス
おそらく最も効率的で合理的な開発努力は、独自のプロトコルを展開するのではなく、既存のプロトコルを利用することに集中することである。Ethereum独自のdevp2p、IPFSのlibp2p及びGNUのGNUnetを含む、いくつかのp2pベースプロトコルがある。これらのプロトコルと特定の構造的な保証、動的なpeer steering、拡張可能なサブプロトコルをサポートするモジュラーピアネットワークを構築するためのそれらの関連性の完全なレビューはこのホワイトペーパーの範囲をはるかに超えているが、Polkadotの実装の重要なステップである。
